// EJB 3.0 final query language
// translated into antlr syntax
// reduced by identifier and path_expression
// without update and delete
// without subquery
// without join and collection
// without projection
// without group
// resolved ambiguous productions
// added some features of CastorQL
// for details refer issue Castor-3999
options{
  //  JDK_VERSION = "1.5";	
STATIC = false;
  NODE_EXTENDS = "ExtendNode";
//  DEBUG_PARSER          = true ;
//  DEBUG_TOKEN_MANAGER   = true ;
}
PARSER_BEGIN(EjbQLParser)
package org.castor.cpa.query.ejbql;
public class EjbQLParser{}PARSER_END(EjbQLParser)
SKIP:{
  " "
  | "\r"
  | "\t"
  | "\n"
}
// Keywords
TOKEN[IGNORE_CASE]:{
  <PLUS:"+">
  | <MINUS:"-">
  | <CONCATE:"||">
  | <MULTIPLY:"*">
  | <DIVIDE:"/">
  | <REMAINDER:"%">
  | <GREATERTHAN:">">
  | <LESSTHAN:"<">
  | <GREATEREQUAL:">=">
  | <LESSEQUAL:"<=">
  | <EQUAL:"=">
  | <NOTEQUAL:"<>">
  | <AS:"AS">
  | <IS:"IS">
  | <IN:"IN">
  | <BY:"BY">
  | <OR:"OR">
  | <ABS:"ABS">
  | <MOD:"MOD">
  | <NIL:"NIL">
  | <AND:"AND">
  | <NOT:"NOT">
  | <ASC:"ASC">
  | <DESC:"DESC">
  | <NULL:"NULL">
  | <FROM:"FROM">
  | <BOTH:"BOTH">
  | <TRIM:"TRIM">
  | <TIME:"TIME">
  | <LIKE:"LIKE">
  | <DATE:"DATE">
  | <SQRT:"SQRT">
  | <ORDER:"ORDER">
  | <WHERE:"WHERE">
  | <LIMIT:"LIMIT">
  | <LOWER:"LOWER">
  | <UPPER:"UPPER">
  | <SELECT:"SELECT">
  | <OFFSET:"OFFSET">
  | <OBJECT:"OBJECT">
  | <CONCAT:"CONCAT">
  | <ESCAPE:"ESCAPE">
  | <LENGTH:"LENGTH">
  | <LOCATE:"LOCATE">
  | <BETWEEN:"BETWEEN">
  | <LEADING:"LEADING">
  | <TRAILING:"TRAILING">
  | <DISTINCT:"DISTINCT">
  | <SUBSTRING:"SUBSTRING">
  | <TIMESTAMP:"TIMESTAMP">
  | <UNDEFINED:"UNDEFINED">
  | <IS_DEFINED:"IS_DEFINED">
  | <IS_UNDEFINED:"IS_UNDEFINED">
  | <CURRENT_DATE:"CURRENT_DATE">
  | <CURRENT_TIME:"CURRENT_TIME">
  | <CURRENT_TIMESTAMP:"CURRENT_TIMESTAMP">
}
TOKEN:{
    <BOOLEAN_LITERAL:<TRUE>  | <FALSE>>
  | <INTEGER_LITERAL:(<DIGIT>)+>
  | <FLOAT_LITERAL:(<DIGIT>)+("."(<DIGIT>)+(("E"  | "e")(<PLUS>  | <MINUS>)?(<DIGIT>)+)?)?>
  | <TIMESTAMP_LITERAL:"'"<DIGIT><DIGIT><DIGIT><DIGIT>"-"<DIGIT><DIGIT>"-"<DIGIT><DIGIT>(" ")*<DIGIT><DIGIT>":"<DIGIT><DIGIT>":"<DIGIT><DIGIT>("."(<DIGIT>)+)?"'">
  | <DATE_LITERAL:"'"<DIGIT><DIGIT><DIGIT><DIGIT>"-"<DIGIT><DIGIT>"-"<DIGIT><DIGIT>"'">
  | <TIME_LITERAL:"'"<DIGIT><DIGIT>":"<DIGIT><DIGIT>":"<DIGIT><DIGIT>("."(<DIGIT>)+)?"'">
  | <CHAR_LITERAL:"'"(~["'", ":", "-"])*("\""(~["'", ":", "-"])*)*"'">
  /* UNICODE IDENTIFIER */
| <IDENTIFIER:<LETTER>(<LETTER>
  | <DIGIT>)*>
  /* UNICODE LETTER */
| <LETTER:[
"\u0024", // for '$'
"\u0041"-"\u005a", // for A-Z
"\u005f", // for '_'
"\u0061"-"\u007a"// for a-z
]>
  /* UNICODE DIGIT */
| <DIGIT:[
"\u0030"-"\u0039"// for 0-9
]>
  | <#TRUE:"TRUE"  | "true">
  | <#FALSE:"FALSE"  | "false">
}
SimpleNode select_statement():{}{
  select_clause()from_clause()(where_clause())?(orderby_clause())?(limit_clause())?{
    return jjtThis;
  }
}
void select_clause():{
  Token t;
}
{
  <SELECT>(t = <DISTINCT>{
    jjtThis.setKind(t.kind);
  }
  )?select_expression()
}
void select_expression():{}{
  path()
  | <OBJECT>"("identifier()")"
}
void from_clause():{}{
  <FROM>from_declaration()
}
void from_declaration():{}{
  path()(<AS>)?identifier()
}
void where_clause():{}{
  <WHERE>conditional_expression()
}
void orderby_clause():{}{
  <ORDER><BY>orderby_item()(","orderby_item())*
}
void orderby_item():{
  Token t;
}
{
  path()(t = <ASC>{
    jjtThis.setKind(t.kind);
  }
  | t = <DESC>{
    jjtThis.setKind(t.kind);
  }
  )?
}
void limit_clause():{}{
  <LIMIT>(integer_literal()
  | parameter())(<OFFSET>(integer_literal()
  | parameter()))?
}
void conditional_expression():{}{
  conditional_term()(<OR>conditional_term())*
}
void conditional_term():{}{
  conditional_factor()(<AND>conditional_factor())*
}
void conditional_factor():{
  Token t;
}
{
  (t = <NOT>{
    jjtThis.setKind(t.kind);
  }
  )?conditional_primary()
}
void conditional_primary():{}{
   LOOKAHEAD(21)"("conditional_expression()")"
  | LOOKAHEAD(21)comparison_expression()
  | LOOKAHEAD(21)between_expression()
  | LOOKAHEAD(21)like_expression()
  | LOOKAHEAD(21)in_expression()
  | LOOKAHEAD(21)null_expression()
}
void comparison_expression():{}{
  expression()comparison_operator()expression()
}
void comparison_operator():{
  Token t;
}
{
  t = <LESSTHAN>{
    jjtThis.setKind(t.kind);
  }
  | t = <LESSEQUAL>{
    jjtThis.setKind(t.kind);
  }
  | t = <GREATEREQUAL>{
    jjtThis.setKind(t.kind);
  }
  | t = <GREATERTHAN>{
    jjtThis.setKind(t.kind);
  }
  | t = <EQUAL>{
    jjtThis.setKind(t.kind);
  }
  | t = <NOTEQUAL>{
    jjtThis.setKind(t.kind);
  }
}
void between_expression():{
  Token t;
}
{
  expression()(t = <NOT>{
    jjtThis.setKind(t.kind);
  }
  )?<BETWEEN>expression()<AND>expression()
}
void like_expression():{
  Token t;
}
{
  expression()(t = <NOT>{
    jjtThis.setKind(t.kind);
  }
  )?<LIKE>(char_literal()
  | parameter())(<ESCAPE>(char_literal()
  | parameter()))?
}
void in_expression():{
  Token t;
}
{
  path()(t = <NOT>{
    jjtThis.setKind(t.kind);
  }
  )?<IN>"("in_item()(","in_item())*")"
}
void in_item():{}{
  LOOKAHEAD(2)path()
  | parameter()
  | literal()
}
void null_expression():{
  Token t;
}
{
  (LOOKAHEAD(2)path()
  | parameter())<IS>(t = <NOT>{
    jjtThis.setKind(t.kind);
  }
  )?<NULL>
}
void expression():{
  Token t;
}
{
  term()((t = <PLUS>{
    jjtThis.setKind(t.kind);
  }
  | t = <MINUS>{
    jjtThis.setKind(t.kind);
  }
  | t = <CONCATE>{
    jjtThis.setKind(t.kind);
  }
  )term())*
}
void term():{
  Token t;
}
{
  factor()((t = <MULTIPLY>{
    jjtThis.setKind(t.kind);
  }
  | t = <DIVIDE>{
    jjtThis.setKind(t.kind);
  }
  | t = <MOD>{
    jjtThis.setKind(t.kind);
  }
  | t = <REMAINDER>{
    jjtThis.setKind(t.kind);
  }
  )factor())*
}
void factor():{
  Token t;
}
{
  (t = <PLUS>{
    jjtThis.setKind(t.kind);
  }
  | t = <MINUS>{
    jjtThis.setKind(t.kind);
  }
  )?primary()
}
void primary():{}{
  ("("expression()")"
  | LOOKAHEAD(2)path()
  | parameter()
  | literal()
  | function())
}
void literal():{}{
  (boolean_literal()
  | LOOKAHEAD(2)integer_literal()
  | float_literal()
  | char_literal())
}
void function():{
  Token t;
}
{
  (t = <LENGTH>{jjtThis.setKind(t.kind);} "("expression()")"
  | t = <LOCATE>{jjtThis.setKind(t.kind);}"("expression()","expression()(","expression())?")"
  | t = <ABS>{jjtThis.setKind(t.kind);}"("expression()")"
  | t = <SQRT>{jjtThis.setKind(t.kind);}"("expression()")"
  | t = <MOD>{jjtThis.setKind(t.kind);}"("expression()","expression()")"
  | t = <CONCAT>{jjtThis.setKind(t.kind);}"("expression()","expression()")"
  | t = <SUBSTRING>{jjtThis.setKind(t.kind);}"("expression()","expression()","expression()")"
  | t = <TRIM>{jjtThis.setKind(t.kind);}"("(LOOKAHEAD(2)(trim_specification())?(char_literal() | parameter())?<FROM>)?expression()")"
  | t = <LOWER>{jjtThis.setKind(t.kind);}"("expression()")"
  | t = <UPPER>{jjtThis.setKind(t.kind);}"("expression()")"
  | t = <CURRENT_DATE>{jjtThis.setKind(t.kind);}
  | t = <CURRENT_TIME>{jjtThis.setKind(t.kind);}
  | t = <CURRENT_TIMESTAMP>{jjtThis.setKind(t.kind);}
  | t = <DATE>{jjtThis.setKind(t.kind);}date_literal()
  | t = <TIME>{jjtThis.setKind(t.kind);}time_literal()
  | t = <TIMESTAMP>{jjtThis.setKind(t.kind);} timestamp_literal())
}
void trim_specification():{
  Token t;
}
{
  t = <LEADING>{
    jjtThis.setKind(t.kind);
  }
  | t = <TRAILING>{
    jjtThis.setKind(t.kind);
  }
  | t = <BOTH>{
    jjtThis.setKind(t.kind);
  }
}
void parameter():{}{
  (positional_parameter()
  | named_parameter())
}
void positional_parameter():{}{
  "?"integer_literal()
}
void named_parameter():{}{
  ":"identifier()
}
void path():{}{
  identifier()("."identifier())*
}
void identifier():{
  Token t;
}
{
  t = <IDENTIFIER>{
    jjtThis.setText(t.image);
  }
}
void float_literal():{
  Token t;
}
{
  t = <FLOAT_LITERAL>{
    jjtThis.setText(t.image);
  }
}
void integer_literal():{
  Token t;
}
{
  t = <INTEGER_LITERAL>{
    jjtThis.setText(t.image);
  }
}
void char_literal():{
  Token t;
}
{
  t = <CHAR_LITERAL>{
    jjtThis.setText(t.image);
  }
}
void boolean_literal():{
  Token t;
}
{
  t = <BOOLEAN_LITERAL>{
    jjtThis.setText(t.image);
  }
}
void timestamp_literal():{
  Token t;
}
{
  t = <TIMESTAMP_LITERAL>{
    jjtThis.setText(t.image);
  }
}
void date_literal():{
  Token t;
}
{
  t = <DATE_LITERAL>{
    jjtThis.setText(t.image);
  }
}
void time_literal():{
  Token t;
}
{
  t = <TIME_LITERAL>{
    jjtThis.setText(t.image);
  }
}

